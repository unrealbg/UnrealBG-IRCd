namespace IRCd.Transport.Tls
{
    using System;
    using System.Collections.Generic;
    using System.Net;
    using System.Net.Security;
    using System.Net.Sockets;
    using System.Security.Authentication;
    using System.Security.Cryptography.X509Certificates;
    using System.Text;
    using System.Threading;
    using System.Threading.Tasks;

    using IRCd.Core.Abstractions;
    using IRCd.Core.Commands;
    using IRCd.Core.Protocol;
    using IRCd.Core.Services;
    using IRCd.Core.State;
    using IRCd.Shared.Options;

    using Microsoft.Extensions.Hosting;
    using Microsoft.Extensions.Logging;
    using Microsoft.Extensions.Options;

    public sealed class TlsListenerHostedService : BackgroundService
    {
        private readonly ILogger<TlsListenerHostedService> _logger;
        private readonly CommandDispatcher _dispatcher;
        private readonly ServerState _state;
        private readonly IOptions<IrcOptions> _options;
        private readonly ISessionRegistry _sessions;
        private readonly HostmaskService _hostmask;
        private readonly ConnectionGuardService _guard;
        private readonly RoutingService _routing;
        private readonly RateLimitService _rateLimit;
        private readonly IHostEnvironment _env;
        private readonly ServerLinkService _links;

        private readonly IRCd.Transport.Tcp.SimpleFloodGate _floodGate = new(maxLines: 20, window: TimeSpan.FromSeconds(10));

        private TcpListener? _listener;
        private X509Certificate2? _cert;
        private Dictionary<string, X509Certificate2>? _sniCerts;

        private readonly object _activeLock = new();
        private readonly Dictionary<string, TlsClientSession> _activeSessions = new(StringComparer.Ordinal);

        public TlsListenerHostedService(
            ILogger<TlsListenerHostedService> logger,
            CommandDispatcher dispatcher,
            ServerState state,
            IOptions<IrcOptions> options,
            ISessionRegistry sessions,
            ConnectionGuardService guard,
            RoutingService routing,
            HostmaskService hostmask,
            RateLimitService rateLimit,
            IHostEnvironment env,
            ServerLinkService links)
        {
            _logger = logger;
            _dispatcher = dispatcher;
            _state = state;
            _options = options;
            _sessions = sessions;
            _guard = guard;
            _routing = routing;
            _hostmask = hostmask;
            _rateLimit = rateLimit;
            _env = env;
            _links = links;
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            var listen = _options.Value.Listen;
            if (listen is null || !listen.EnableTls)
                return;

            var certPath = listen.TlsCertificatePath;

            if (string.IsNullOrWhiteSpace(certPath) && listen.AutoGenerateSelfSignedCertificate)
            {
                try
                {
                    _cert = SelfSignedCertificateGenerator.CreateAndPersistPfx(
                        _env.ContentRootPath,
                        listen.AutoGeneratedCertPath,
                        listen.AutoGeneratedCertPassword,
                        listen.AutoGeneratedCertCommonName,
                        listen.AutoGeneratedCertDaysValid);

                    _logger.LogWarning(
                        "Generated self-signed TLS certificate at {Path}. This is intended for dev/test, not production.",
                        listen.AutoGeneratedCertPath);

                    certPath = listen.AutoGeneratedCertPath;
                    listen.TlsCertificatePath = certPath;
                    listen.TlsCertificatePassword = listen.AutoGeneratedCertPassword;
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Failed to auto-generate self-signed TLS certificate. TLS listener will not start.");
                    return;
                }
            }

            if (string.IsNullOrWhiteSpace(certPath))
            {
                _logger.LogWarning("TLS enabled but TlsCertificatePath is empty. TLS listener will not start.");
                return;
            }

            try
            {
                var fullPath = certPath;
                if (!System.IO.Path.IsPathRooted(fullPath))
                    fullPath = System.IO.Path.Combine(_env.ContentRootPath, fullPath);

                if (!System.IO.File.Exists(fullPath) && listen.AutoGenerateSelfSignedCertificate)
                {
                    _cert = SelfSignedCertificateGenerator.CreateAndPersistPfx(
                        _env.ContentRootPath,
                        listen.AutoGeneratedCertPath,
                        listen.AutoGeneratedCertPassword,
                        listen.AutoGeneratedCertCommonName,
                        listen.AutoGeneratedCertDaysValid);
                }
                else
                {
                    _cert = string.IsNullOrWhiteSpace(listen.TlsCertificatePassword)
                        ? X509CertificateLoader.LoadPkcs12FromFile(fullPath, null)
                        : X509CertificateLoader.LoadPkcs12FromFile(fullPath, listen.TlsCertificatePassword);
                }

                if (listen.TlsCertificates is not null && listen.TlsCertificates.Count > 0)
                {
                    _sniCerts = new Dictionary<string, X509Certificate2>(StringComparer.OrdinalIgnoreCase);

                    foreach (var kv in listen.TlsCertificates)
                    {
                        var name = kv.Key?.Trim();
                        var cfg = kv.Value;
                        if (string.IsNullOrWhiteSpace(name) || cfg is null || string.IsNullOrWhiteSpace(cfg.Path))
                            continue;

                        var p = cfg.Path;
                        if (!System.IO.Path.IsPathRooted(p))
                            p = System.IO.Path.Combine(_env.ContentRootPath, p);

                        if (!System.IO.File.Exists(p))
                            continue;

                        var c = string.IsNullOrWhiteSpace(cfg.Password)
                            ? X509CertificateLoader.LoadPkcs12FromFile(p, null)
                            : X509CertificateLoader.LoadPkcs12FromFile(p, cfg.Password);

                        _sniCerts[name] = c;
                    }
                }

                _logger.LogInformation(
                    "TLS certificate loaded. Subject={Subject} Thumbprint={Thumbprint}",
                    _cert.Subject,
                    _cert.Thumbprint);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to load TLS certificate from {Path}", listen.TlsCertificatePath);
                return;
            }

            var ip = IPAddress.Any;
            if (!string.IsNullOrWhiteSpace(listen.BindIp) && IPAddress.TryParse(listen.BindIp, out var parsed))
                ip = parsed;

            var port = listen.TlsClientPort > 0 ? listen.TlsClientPort : 6697;

            _listener = new TcpListener(ip, port);
            _listener.Start();

            _logger.LogInformation("IRCd TLS listening on {IP}:{Port}", ip, port);

            while (!stoppingToken.IsCancellationRequested)
            {
                TcpClient client;
                try
                {
                    client = await _listener.AcceptTcpClientAsync(stoppingToken);
                }
                catch (OperationCanceledException)
                {
                    break;
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex, "TLS Accept failed");
                    continue;
                }

                _ = Task.Run(() => HandleClientAsync(client, stoppingToken), stoppingToken);
            }
        }

        public override Task StopAsync(CancellationToken cancellationToken)
        {
            try { _listener?.Stop(); } catch { }

            TlsClientSession[] sessions;
            lock (_activeLock)
            {
                sessions = _activeSessions.Values.ToArray();
            }

            foreach (var s in sessions)
            {
                try { _ = s.CloseAsync("Server shutting down", cancellationToken); } catch { }
            }

            try
            {
                if (_sniCerts is not null)
                {
                    foreach (var c in _sniCerts.Values)
                    {
                        try { c.Dispose(); } catch { }
                    }

                    _sniCerts = null;
                }
            }
            catch { }
            return base.StopAsync(cancellationToken);
        }

        private static IPAddress GetRemoteIp(TcpClient client)
        {
            if (client.Client.RemoteEndPoint is IPEndPoint ep)
                return ep.Address;

            return IPAddress.None;
        }

        private async Task HandleClientAsync(TcpClient client, CancellationToken ct)
        {
            var remoteIp = GetRemoteIp(client);

            if (_guard.Enabled)
            {
                if (!_guard.TryAcceptNewConnection(remoteIp, out var rejectReason))
                {
                    try
                    {
                        using var stream = client.GetStream();
                        using var writer = new System.IO.StreamWriter(stream, new UTF8Encoding(false))
                        {
                            NewLine = "\r\n",
                            AutoFlush = true
                        };

                        await writer.WriteLineAsync($"ERROR :{rejectReason}");
                    }
                    catch { }

                    try { client.Close(); } catch { }
                    return;
                }
            }

            var connectionId = Guid.NewGuid().ToString("N");

            EndPoint remoteEndPoint = client.Client.RemoteEndPoint ?? new IPEndPoint(IPAddress.None, 0);

            using var net = client.GetStream();

            RemoteCertificateValidationCallback? remoteCertValidation = null;
            LocalCertificateSelectionCallback? certSelector = null;

            if (_sniCerts is not null && _sniCerts.Count > 0)
            {
                certSelector = (sender, name, localCertificates, remoteCertificate, acceptableIssuers) =>
                {
                    var fallback = _cert ?? throw new InvalidOperationException("TLS certificate not loaded");

                    if (string.IsNullOrWhiteSpace(name))
                        return fallback;

                    return _sniCerts.TryGetValue(name, out var chosen) ? chosen : fallback;
                };
            }

            using var ssl = certSelector is null
                ? new SslStream(net, leaveInnerStreamOpen: false)
                : new SslStream(net, leaveInnerStreamOpen: false, remoteCertValidation, certSelector);

            try
            {
                var authOptions = new SslServerAuthenticationOptions
                {
                    ServerCertificate = _cert,
                    EnabledSslProtocols = SslProtocols.Tls12 | SslProtocols.Tls13,
                    CertificateRevocationCheckMode = X509RevocationMode.NoCheck,
                    AllowRenegotiation = false,
                };

                await ssl.AuthenticateAsServerAsync(authOptions, ct);
            }
            catch (Exception ex)
            {
                _logger.LogInformation(ex, "TLS handshake failed from {Remote}", remoteEndPoint);
                try { client.Close(); } catch { }

                if (_guard.Enabled)
                {
                    try { _guard.ReleaseActive(remoteIp); } catch { }
                    try { _guard.ReleaseUnregistered(remoteIp); } catch { }
                }

                return;
            }

            var session = new TlsClientSession(connectionId, remoteEndPoint, ssl);

            lock (_activeLock)
            {
                _activeSessions[connectionId] = session;
            }

            var now = DateTimeOffset.UtcNow;
            var host = _hostmask.GetDisplayedHost(remoteIp);

            _state.TryAddUser(new User
            {
                ConnectionId = connectionId,
                ConnectedAtUtc = now,
                LastActivityUtc = now,
                Host = host,
                IsSecureConnection = true
            });

            _sessions.Add(session);

            _logger.LogInformation("TLS client connected {ConnId} from {Remote}", connectionId, session.RemoteEndPoint);

            var writerTask = Task.Run(() => session.RunWriterLoopAsync(ct), ct);

            var serverName = _options.Value.ServerInfo?.Name ?? "server";
            await session.SendAsync($":{serverName} NOTICE * :Welcome (TLS). Use NICK/USER.", ct);

            Task<string?>? pendingRead = null;

            var registrationDeadlineUtc = DateTimeOffset.UtcNow.AddSeconds(_guard.GetRegistrationTimeoutSeconds());
            var unregisteredReleased = false;
            var markedRegistered = false;

            try
            {
                while (!ct.IsCancellationRequested)
                {
                    if (_guard.Enabled && !session.IsRegistered && DateTimeOffset.UtcNow > registrationDeadlineUtc)
                    {
                        try { await session.SendAsync("ERROR :Registration timeout", ct); } catch { }
                        try { await session.CloseAsync("Registration timeout", ct); } catch { }
                        break;
                    }

                    pendingRead ??= session.ReadLineAsync(ct);

                    var tick = Task.Delay(TimeSpan.FromSeconds(1), ct);
                    var completed = await Task.WhenAny(pendingRead, tick);

                    if (completed != pendingRead)
                        continue;

                    string? line;
                    try
                    {
                        line = await pendingRead;
                    }
                    catch (ObjectDisposedException) { break; }
                    catch (InvalidOperationException) { break; }

                    pendingRead = null;

                    if (line is null)
                        break;

                    if (string.IsNullOrWhiteSpace(line))
                        continue;

                    if (!_floodGate.Allow(connectionId))
                    {
                        try { await session.SendAsync("ERROR :Excess Flood", ct); } catch { }
                        try { await session.CloseAsync("Excess Flood", ct); } catch { }
                        break;
                    }

                    session.OnInboundLine();

                    IrcMessage msg;
                    try
                    {
                        msg = IrcParser.ParseLine(line);
                    }
                    catch (Exception ex)
                    {
                        _logger.LogDebug(ex, "Bad line from {ConnId}: {Line}", connectionId, line);
                        continue;
                    }

                    await _dispatcher.DispatchAsync(session, msg, _state, ct);

                    if (!markedRegistered && session.IsRegistered)
                    {
                        markedRegistered = true;

                        if (_guard.Enabled)
                        {
                            _guard.MarkRegistered(remoteIp);
                            unregisteredReleased = true;
                        }
                    }
                }
            }
            catch (OperationCanceledException)
            {
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "TLS client loop error {ConnId}", connectionId);
            }
            finally
            {
                try
                {
                    if (session.IsRegistered && !string.IsNullOrWhiteSpace(session.Nick))
                    {
                        var nick = session.Nick!;
                        var user = session.UserName ?? "u";
                        var displayedHost = host;

                        var quitLine = $":{nick}!{user}@{displayedHost} QUIT :Client disconnected";

                        var recipients = new HashSet<string>(StringComparer.Ordinal);

                        foreach (var chName in _state.GetUserChannels(connectionId))
                        {
                            if (_state.TryGetChannel(chName, out var ch) && ch is not null)
                            {
                                foreach (var m in ch.Members)
                                {
                                    if (m.ConnectionId != connectionId)
                                        recipients.Add(m.ConnectionId);
                                }
                            }
                        }

                        foreach (var rid in recipients)
                        {
                            await _routing.SendToUserAsync(rid, quitLine, CancellationToken.None);
                        }

                        if (_state.TryGetUser(connectionId, out var meUser) && meUser is not null && !string.IsNullOrWhiteSpace(meUser.Uid))
                        {
                            await _links.PropagateQuitAsync(meUser.Uid!, "Client disconnected", CancellationToken.None);
                        }
                    }
                }
                catch { }

                try { _sessions.Remove(connectionId); } catch { }
                try { _state.RemoveUser(connectionId); } catch { }
                try { _rateLimit.ClearConnection(connectionId); } catch { }
                try { _floodGate.Remove(connectionId); } catch { }

                lock (_activeLock)
                {
                    _activeSessions.Remove(connectionId);
                }

                if (_guard.Enabled && !session.IsRegistered && !unregisteredReleased)
                {
                    try { _guard.ReleaseUnregistered(remoteIp); } catch { }
                }

                if (_guard.Enabled)
                {
                    try { _guard.ReleaseActive(remoteIp); } catch { }
                }

                try { await session.CloseAsync("Client disconnected", CancellationToken.None); } catch { }

                _logger.LogInformation("TLS client disconnected {ConnId}", connectionId);
            }

            try { await writerTask; } catch { }
        }
    }
}
